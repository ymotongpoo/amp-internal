+++
date = "2016-10-11T16:14:23+09:00"
draft = false
title = "Generating AMP JS"
tags = ["gulp", "gulpfule.js"]
+++

## Preface

Before digging into the repository of AMP HTML, let's see how AMP elements works in the browser at first hand. 

The specification of AMP HTML tag set is combination of subset of HTML5 and custom elements. All builtin custom elements and whole AMP runtime is implemented in AMP JS, which is hosted in the wild on `https://cdn.ampproject.org/v0.js`.
Other third party extensional custom elements, such as `amp-analytics`, `amp-ad` and so on are handled in special JavaScript with the elements' names.

The following snippets is from existing AMP page in the production.

```html
<script custom-element="amp-font" src="https://cdn.ampproject.org/v0/amp-font-0.1.js" async></script>
<script custom-element="amp-ad" src="https://cdn.ampproject.org/v0/amp-ad-0.1.js" async></script>
<script custom-element="amp-analytics" src="https://cdn.ampproject.org/v0/amp-analytics-0.1.js" async></script>
...
<script src="https://cdn.ampproject.org/v0.js" async></script>
```

All JavaScripts for AMP are hosted under `https://cdn.ampproject.org/`. So it seems that we should take a look at where all those JavaScripts are located, or generated in the repository.

You may find that there's no file named `v0.js` in the repository once you hit the `find` command on the console. Also, you may find thet there's no files with the name of `[CUSTOM ELEMENT NAME]-[VERSION].js` neither, though you find directories under `extensions` directory that look dedicated for each custom elements, such as `amp-ad`, `amp-audio` and so on.

The reason of this is because there JavaScript files are generated by the process run by `gulp`. So let's take a look at `gulpfile.js` and understand how these files are generated.

## compileJs()
As soon as searching the string `'v0.js'` in the `gulpfile.js`, you'll find the function `compile()` that runs `compileJs()` for a couple of times, `compileCss()` and `thirdPartyBootstrap()`. Since what we are interested in is `v0.js`, `compileJs()` would give some hints for the generation process of `v0.js`.

```js
/**
 * Compile a javascript file
 *
 * @param {string} srcDir Path to the src directory
 * @param {string} srcFilename Name of the JS source file
 * @param {string} destDir Destination folder for output script
 * @param {?Object} options
 */
function compileJs(srcDir, srcFilename, destDir, options) {
```

The function definition and comments with it describes well how it works. The function call in `compile()` to generate `v0.js` is following:

```js
  // For compilation with babel we start with the amp-babel entry point,
  // but then rename to the amp.js which we've been using all along.
  compileJs('./src/', 'amp-babel.js', './dist', {
    toName: 'amp.js',
    minifiedName: 'v0.js',
    includePolyfills: true,
    checkTypes: opt_checkTypes,
    watch: watch,
    preventRemoveAndMakeDir: opt_preventRemoveAndMakeDir,
    minify: shouldMinify,
    // If there is a sync JS error during initial load,
    // at least try to unhide the body.
    wrapper: 'try{(function(){<%= contents %>})()}catch(e){' +
        'setTimeout(function(){' +
        'var s=document.body.style;' +
        's.opacity=1;' +
        's.visibility="visible";' +
        's.animation="none";' +
        's.WebkitAnimation="none;"},1000);throw e};'
  });
```

Though I'm not a babel expert, the function call sounds like creating `./dist/v0.js` in some condition. With that expectation, let's take a closer look in `compileJs()`.

```js
function compileJs(srcDir, srcFilename, destDir, options) {
  options = options || {};
  if (options.minify) {
    function minify() {
      console.log('Minifying ' + srcFilename);
      closureCompile(srcDir + srcFilename, destDir, options.minifiedName,
          options)
          .then(function() {
            appendToCompiledFile(srcFilename, destDir + '/' + options.minifiedName);
            fs.writeFileSync(destDir + '/version.txt', internalRuntimeVersion);
            if (options.latestName) {
              fs.copySync(
                  destDir + '/' + options.minifiedName,
                  destDir + '/' + options.latestName);
            }
          });
    }
    minify();
    return;
  }
  ...
```

Ok, great. In the internal function `minify()`, we see the line `closureCompile(srcDir + srcFilename, destDir, options.minifiedName, options)`. [^gulp1] `closureCompile()` is imported from `build-system/tasks/compile.js`.

```js
// Compiles AMP with the closure compiler. This is intended only for
// production use. During development we intent to continue using
// babel, as it has much faster incremental compilation.
exports.closureCompile = function(entryModuleFilename, outputDir,
    outputFilename, options) {
  // Rate limit closure compilation to MAX_PARALLEL_CLOSURE_INVOCATIONS
  // concurrent processes.
  return new Promise(function(resolve) {
    function start() {
      inProgress++;
      compile(entryModuleFilename, outputDir, outputFilename, options)
          .then(function() {
            inProgress--;
            next();
            resolve();
          }, function(e) {
            console./*OK*/error('Compilation error', e.message);
            process.exit(1);
          });
    }
    function next() {
      if (!queue.length) {
        return;
      }
      if (inProgress < MAX_PARALLEL_CLOSURE_INVOCATIONS) {
        queue.shift()();
      }
    }
    queue.push(start);
    next();
  });
};
```

It seems the internal function `start()` inside Promise() is doing something, because it is pushed to the array variable `queue` at the end of the Promise and called in the internal function `next()` that is called at the very last of the Promise. (`queue.shift()()` is.)

And the function `compile()` is implemented like this. 

[^gulp1]: `appendToCompileFile()` is called only in the case of the `srcFilename` is `"amp-viz-vega.js"` so ignore it in this case. 
